<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SPACES - svg drawing tool</title>
		<meta charset="utf-8">
		<meta name="description" content="Vue.js svg editor">
		<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
		<style>
			svg:focus { outline: none; }
		</style>
	</head>
	<body>
		<div id="app">
			<svg id="svgCanvas" width="400" height="400" 
				v-on:click="clic($event)"
				v-on:mousemove="move($event)"
				v-on:keyup.z.ctrl="cancel" tabindex="0">
				
				<path v-for="shape in shapes" :d="getPath(shape.points, true)" stroke="white" fill="black" />
				
				<path :d="currentPath" stroke="black" fill="none" stroke-width="1" />
				
				<template v-for="guide in guides" >
					<anchor v-bind:point="guide.p1" v-bind:type="2" />
					<anchor v-bind:point="guide.p2" v-bind:type="2"/>
				</template>

				<anchor v-if="showStartPoint" v-bind:point="startPoint" v-bind:type="1" />
			</svg>
		</div>
	</body>
	<script>
		var formsGap = 10;

		class Point {
			constructor(x,y) {
				if (x && y) {
					this.x = x;
					this.y = y;
				}
				else {
					this.x = 0;
					this.y = 0;
				}

				this.isMouseOver = false;
			}

			getSqDistanceFrom(p2) {
				let dx = p2.x - this.x;
				let dy = p2.y - this.y;
				return Math.sqrt(dx * dx + dy * dy);
			}
		}

		class Segment {
			constructor(p1,p2) {
				this.p1 = p1;
				this.p2 = p2;
			}
		}

		class Shape {
			constructor(points) {
				this.points = points;
				this.guides = getGuides(points);
			}
		}

		//To know which side of an edge is inside the form
		// > the right side of an edge (points[i], points[i+1]) will be inside if clockwise is true
		//Sum over the edges, (x2-x1)(y2+y1)
		//http://en.wikipedia.org/wiki/Shoelace_formula
		//http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order/1165943#1165943
		function isFormClockwiseOriented(points) {    
		    let i;
		    let sum = 0;
		    for (i=0; i< points.length - 1; i++) {
		        sum += (points[i+1].x - points[i].x) * (points[i+1].y + points[i].y);
		    }
		    sum += (points[0].x- points[i].x) * (points[0].y + points[i].y);

		    return sum <= 0;
		}

		function getGuides(points) {

			let guides = [];
			let clockwise = isFormClockwiseOriented(points);

			let getCycled = (array, i) => array[i % array.length];

			for (let i=0; i < points.length; i++) {
				guides.push(
					getGuideForBCSegment(
						getCycled(points, i),
						getCycled(points, i+1),
						getCycled(points, i+2),
						getCycled(points, i+3),
						clockwise,
					)
				);
			}

			//if the corner is concave, get intersection between guides
			for (let i=0; i < guides.length; i++) {
				let current = getCycled(guides, i);
				let next = getCycled(guides, i+1);

				if (clockwise != isFormClockwiseOriented([current.p1, current.p2, next.p1, next.p2]))
					current.p2 = next.p1 = getIntersection(current, next);
			}

			return guides;
		}

		function getGuideForBCSegment(A, B, C, D, isFormClockwise) {
			//move form's segment outside the form to get the guide's line
			let movedBCSegment = moveSegmentOutside(B,C, formsGap, isFormClockwise);

			// compute this line's intersections with the form's previous and next segment
			// to get guide's key points
			let I = getIntersection(new Segment(A,B), movedBCSegment);
			let J = getIntersection(new Segment(C,D), movedBCSegment);

			//TODO : optimize if the corner is concave by not computing a point that will be changed later...

			return new Segment(I,J);
		}

		function moveSegmentOutside(A, B, distance, isFormClockwise) {
			let dX = B.x - A.x;
			let dY = B.y - A.y;

			if (dX == 0)
				dX = 0.01;
			let x = -1 * dY / dX;
    		let sizeFactor = distance / Math.sqrt(x*x + 1);

		    if ((dX > 0 && isFormClockwise) || (dX < 0 && !isFormClockwise))
		        sizeFactor *= -1;

		    return new Segment(
		    	new Point(sizeFactor * x + A.x, sizeFactor + A.y),
		    	new Point(sizeFactor * x + B.x, sizeFactor + B.y)
	     	);
		}

		function getIntersection(u, v) {
			let x1 = u.p1.x;
			let x2 = u.p2.x;
			let x3 = v.p1.x;
			let x4 = v.p2.x;
			let y1 = u.p1.y;
			let y2 = u.p2.y;
			let y3 = v.p1.y;
			let y4 = v.p2.y;

	        let a = ((y4-y3)*(x1-x3)-(x4-x3)*(y1-y3)) / ((x4-x3)*(y2-y1)-(y4-y3)*(x2-x1));
        	return new Point(x1 + (x2-x1) * a, y1 + (y2-y1) * a);
		}


		const AnchorType = { startPoint:1, guide:2 };
		Object.freeze(AnchorType);
		

		Vue.component('anchor', {
  			props: ['point', 'type'],
  			template: '<circle :cx="point.x" :cy="point.y" :r="size" :stroke="strokeColor" stroke-width="1" :fill="fillColor" />',
  			computed: {
  				size: function() { return this.point.isMouseOver ? 5 : 3 },
  				strokeColor: function() {  
					if (this.type == AnchorType.guide)
  						return "#ff0000";
  					else
  						return "transparent";
  				},
  				fillColor: function() {
  					if (this.type == AnchorType.startPoint) 
  						return "#318be7";
  					else
  						return "transparent";
  				}
  			}
		});


		var app = new Vue({
		  el: '#app',
		  data: {
		  	snapThreshold: 20,

			currentPoint: new Point(),
			currentShape: [],
			shapes: [],
		  },
		  computed: {
			showStartPoint: function () {
				return this.currentShape.length > 2;
			},
			startPoint: function () {
				if (this.currentShape.length <= 0)
					return undefined;

				return this.currentShape[0];
			},
			currentPath: function () {
				return this.getPath(this.currentShape.concat(this.currentPoint));
			},
			guides: function () {
				return this.shapes.map(s => s.guides).flat();
			}
		  },
		  methods: {
			getPosition: function (event) {
				rect = document.getElementById('svgCanvas').getBoundingClientRect();

				return new Point( 
					event.clientX - rect.left,
					event.clientY - rect.top
				);
			},
			getPath: function (shape, closeShape) {
				let path = "";
				shape.forEach(function(s, i) {
					path += (i == 0 ? "M" : "L");
					path += s.x + " " + s.y + " ";
				});
				if (closeShape)
					path += "Z";

				return path;
			},
			isSnappedAtStartPoint: function (point) {
				return this.showStartPoint && point.getSqDistanceFrom(this.currentShape[0]) < this.snapThreshold;
			},
			closeCurrentShape: function () {
				this.shapes.push(new Shape(this.currentShape));
				this.currentShape = [];
			},
			getSnappedPosition: function (mouseEvent, updateUI) {
				let snappedPoint = this.getPosition(mouseEvent);
				let nearestPoint;
				let nearestDistance = this.snapThreshold;
				let allAnchors = this.guides
					.map(g => [g.p1, g.p2])
					.flat();

				if (this.showStartPoint)
					allAnchors.push(this.startPoint);

				allAnchors.forEach(a => {
					if (updateUI)
						a.isMouseOver = false;

					let d = a.getSqDistanceFrom(snappedPoint);
					if (d < nearestDistance) {
						nearestDistance = d;
						nearestPoint = a;
					}
				});

				if (nearestPoint != null) {
					snappedPoint = nearestPoint;
					
					if (updateUI)
						nearestPoint.isMouseOver = true;
				}

				return snappedPoint;
			},
			move: function (event) {
				this.currentPoint = this.getSnappedPosition(event, true);
			},
			clic: function (event) {
				let snappedPoint = this.getSnappedPosition(event, false);
				if (this.showStartPoint && snappedPoint == this.startPoint)
					this.closeCurrentShape();
				else
					this.currentShape.push(snappedPoint);
			},
			cancel: function () {
				if (this.startPoint !== undefined)
					this.currentShape.pop();
				else
					this.shapes.pop();
			}
		  }
		})
	</script>
</html>
